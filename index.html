<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Elbasani - Cinematic Reveal</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 10);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Bloom effect
        const bloomParams = {
            exposure: 1,
            bloomStrength: 1.5,
            bloomThreshold: 0,
            bloomRadius: 0.5
        };
        
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            bloomParams.bloomStrength,
            bloomParams.bloomRadius,
            bloomParams.bloomThreshold
        );
        
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        const redLight = new THREE.PointLight(0xff0000, 5, 10);
        redLight.position.set(-3, 3, 5);
        scene.add(redLight);
        
        const blueLight = new THREE.PointLight(0x0066ff, 5, 10);
        blueLight.position.set(3, 3, 5);
        scene.add(blueLight);
        
        // Car parts (simplified for demo - in a real project you'd use a 3D model)
        const carParts = [];
        const partNames = ['hood', 'leftDoor', 'rightDoor', 'frontWheel1', 'frontWheel2', 'rearWheel1', 'rearWheel2', 'windshield', 'headlight1', 'headlight2'];
        
        // Create simplified car parts
        const carBody = new THREE.Mesh(
            new THREE.BoxGeometry(4, 1.2, 1.8),
            new THREE.MeshPhongMaterial({ 
                color: 0x111111, 
                metalness: 0.9, 
                roughness: 0.1,
                emissive: 0x000000,
                emissiveIntensity: 0
            })
        );
        carBody.castShadow = true;
        scene.add(carBody);
        carParts.push(carBody);
        
        // Create other parts
        partNames.forEach((part, i) => {
            let geometry, position;
            
            switch(part) {
                case 'hood':
                    geometry = new THREE.BoxGeometry(1.8, 0.1, 1.6);
                    position = [0, 0.65, 0.8];
                    break;
                case 'leftDoor':
                    geometry = new THREE.BoxGeometry(0.8, 1, 0.1);
                    position = [-1.2, 0.1, 0];
                    break;
                case 'rightDoor':
                    geometry = new THREE.BoxGeometry(0.8, 1, 0.1);
                    position = [1.2, 0.1, 0];
                    break;
                case 'windshield':
                    geometry = new THREE.BoxGeometry(1.6, 0.6, 0.1);
                    position = [0, 0.6, 0.4];
                    break;
                default: // wheels and lights
                    geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32);
                    position = [
                        i % 2 === 0 ? -1 : 1,
                        -0.4,
                        i < 5 ? 0.8 : -0.8
                    ];
            }
            
            const material = new THREE.MeshPhongMaterial({ 
                color: part.includes('light') ? 0xffffff : 0x222222,
                metalness: 0.9,
                roughness: 0.1
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            if (part.includes('Wheel')) {
                mesh.rotation.x = Math.PI / 2;
            }
            
            mesh.position.set(...position);
            mesh.castShadow = true;
            scene.add(mesh);
            carParts.push(mesh);
        });
        
        // Text geometry
        let textMesh;
        const createText = () => {
            const loader = new THREE.FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three@0.132.2/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                const textGeometry = new THREE.TextGeometry('Auto Elbasani', {
                    font: font,
                    size: 0.5,
                    height: 0.2,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.03,
                    bevelSize: 0.02,
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                
                textGeometry.center();
                
                const textMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaaaaaa,
                    metalness: 1.0,
                    roughness: 0.1,
                    emissive: 0x444444,
                    emissiveIntensity: 0.5
                });
                
                textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.y = 2;
                textMesh.visible = false;
                scene.add(textMesh);
            });
        };
        createText();
        
        // Animation timeline
        const animate = () => {
            requestAnimationFrame(animate);
            
            // Rotate camera
            if (time < 5) {
                camera.position.x = Math.sin(time * 0.2) * 8;
                camera.position.z = Math.cos(time * 0.2) * 8;
                camera.lookAt(0, 1, 0);
            }
            
            // Update bloom effect
            composer.render();
        };
        
        // GSAP timeline for animations
        let time = 0;
        const tl = gsap.timeline({ defaults: { duration: 1, ease: "power2.inOut" } });
        
        // Initial camera movement
        tl.to(camera.position, { 
            z: 6, 
            y: 1.5,
            duration: 2,
            ease: "power2.inOut"
        }, 0);
        
        // Car parts explosion
        tl.add(() => {
            carParts.forEach((part, i) => {
                const targetPos = {
                    x: part.position.x + (Math.random() - 0.5) * 5,
                    y: part.position.y + (Math.random() - 0.5) * 3,
                    z: part.position.z + (Math.random() - 0.5) * 5
                };
                
                gsap.to(part.position, {
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z,
                    duration: 1.5,
                    delay: i * 0.05,
                    ease: "power2.out"
                });
                
                gsap.to(part.rotation, {
                    x: Math.random() * Math.PI * 2,
                    y: Math.random() * Math.PI * 2,
                    z: Math.random() * Math.PI * 2,
                    duration: 1.5,
                    delay: i * 0.05,
                    ease: "power2.out"
                });
            });
        }, 3);
        
        // Assemble text
        tl.add(() => {
            if (!textMesh) return;
            
            textMesh.visible = true;
            textMesh.scale.set(0.1, 0.1, 0.1);
            
            gsap.to(textMesh.scale, {
                x: 1,
                y: 1,
                z: 1,
                duration: 2,
                ease: "elastic.out(1, 0.3)"
            });
            
            // Move camera to focus on text
            gsap.to(camera.position, {
                x: 0,
                y: 2,
                z: 5,
                duration: 2
            });
            
            // Add neon light effects
            const neonPulse = () => {
                gsap.to(redLight, {
                    intensity: 8,
                    duration: 0.5,
                    yoyo: true,
                    repeat: -1
                });
                
                gsap.to(blueLight, {
                    intensity: 8,
                    duration: 0.5,
                    delay: 0.25,
                    yoyo: true,
                    repeat: -1
                });
            };
            
            neonPulse();
        }, 5);
        
        // Time update for camera rotation
        const clock = new THREE.Clock();
        const render = () => {
            time = clock.getElapsedTime();
            animate();
        };
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        render();
    </script>
</body>
</html>
